################################################################################################################################################################
########################################################################### GIT ################################################################################
################################################################################################################################################################

#####Comando GIT#####
#Subir con GitHub el codigo fuente
git init //Inicializar nuestro repositorio
git add . //Prepara todos los archivos modificados
git commit -m "primer commit" //Toma la "fotografia" de los archivos modificados
git checkout -- . //Reconstruye los fuentes al ultimo commit
git checkout -b nombre_rama //Crea una rama con el nombre indicado y se para en ella
git checkout nombre_rama // Selecciona la rama indicada y se para en ella
git branch // Para ver las ramas
git branch -M main //Renombra la rama donde nos encontramos y le cambia el nombre a main
git remote add origin https://github.com/Divier/seccion_7_curso_angular_gifs.git (Este ya debe existir, crear previamente en github.com)
git push -u origin main
git restore --staged index.html  //Permite deshacer un git add
#Generar version
git tag -a v1.0 -m "Fin base angular"
#Ver la version
git tag
#Para subir el tag creado a GitHub
git push --tags
#Luego de crear el tag, en GitHub se crea el Release Tag
En tags - edit
#Clonar un repositorio
git clone https://github.com/EscuelaIt/angular-avanzado.git . 
El último punto le indica que el clon lo vas a colocar en la carpeta donde estás situado
#En GitHub el uso de fork para sacar una copia de un repositorio existente
Esto es, un repositorio que es copia de otro que ya está publicado en GitHub


################################################################################################################################################################
################################################################### Visual Studio Code #########################################################################
################################################################################################################################################################

Extensiones
- Paste JSON as code
- TODO Highlight
- Todo Tree
- Material Icon
- Color Highlight
- Bracket pair colorizer 2
- Auto Close Tag
- TypeScript Importer
- Activitus Bar
- Angular Language Service
- Angular Snippets
- Angular Schematics
- Angular2-inline
- Auto Rename Tag
- Auto Import
- Error Lens
- EditorConfig for VS Code
- Better Comments
- Terminal
- Tailwind CSS IntelliSense

- Abrir consola Crtl+Ñ
- Buscar Archivo Ctrl+P


################################################################################################################################################################
########################################################################## Node ################################################################################
################################################################################################################################################################

#####Backend Node#####
Para crear un servidor que sirva como backend para pruebas
npm install -g json-server
Para subir un API Rest que simule un backend:
json-server --watch db.json (Ubicandose en la ruta donde este el archivo db.json)

# Crear archivo package.json
>npm init -y


# Instalar paquete para que tome los cambios en caliente
>npm i nodemon -g


# Para ejecutar un archivo javascript
>nodemon index.js 


#En el package.json se pueden configurar los script a ejecutar
"scripts": {
    "dev": "nodemon index.js", //>npm run dev
    "start": "node index.js" //>npm start
},


# Para instalar express (Framework)
>npm i express


# Para utilizar variables de entorno (dotenv)
>npm i dotenv


# Para instalar express validator (para validar campos)
>npm i express-validator


# Middlewares
- Son funciones con esta firma (req, res, next)
- Deben llamar al metodo next() si todo sale bien


# Status Codes
https://www.restapitutorial.com/httpstatuscodes.html


# Mongoose
Mongoose es una librería para Node.js que nos permite escribir consultas para una base de datos de MongooDB, con características como validaciones, construcción de queries, middlewares, conversión de tipos y algunas otras, que enriquecen la funcionalidad de la base de datos.
https://mongoosejs.com/
Para instalarlo:
>npm i mongoose


# Para instalar bcrypt // encriptar contraseñas
>npm i bcryptjs


# Para utilizar JWT (Json Web Token)
https://jwt.io/
Para instalarlo:
>npm i jsonwebtoken


# Para utilizar CORS
https://enable-cors.org/
>npm i cors


# Para instalar libreria para manejo de fechas (moment)
npm i moment


# Para probar una aplicacion Angular o React se puede instalar un servidor http local (http-server)
>npm install -g http-server
- Ubicandose en el directorio dist, se puede ejecutar lo siguiente para subir la aplicacion
>http-server -o
- Importante decir que en react el modo stricto no esta habilitado en produccion, en desarrollo si.
- Importante decir que en react el modo stricto al estar habilitado en desarrollo puede generar mas de una ejecucion al utilizar el hook useEffect, o el useLayoutEffect.


# Para probar una aplicacion Angular o React se puede instalar un servidor http local (serve)
Serve lo ayuda a servir un sitio estático, una aplicación de una sola página o simplemente un archivo estático (no importa si está en su dispositivo o en la red local).
>npm install --global serve
- Ubicandose en el directorio raiz del proyecto, se puede ejecutar lo siguiente para subir la aplicacion
>serve -s dist


# Manejo de archivos
>npm i express-fileupload

################################################################################################################################################################
####################################################################### TypeScript #############################################################################
################################################################################################################################################################

npm install -g ts-node
npm install -g typescript (Instala TypeScript de forma global)
tsc --version
tsc app (Genera el archivo .js correspondiente)
tsc --init (Genera el archivo tsconfig.json)
Con el archivo tsconfig.json creado se puede ejecutar:
tsc (Para generar todos los js que requiera la aplicacion y no uno por uno)
tsc -w (Este comando permite estar mirando los cambios en cualquier archivo y hace la transpilacion de manera automatica)

npm init (crear el archivo package.json)

Para utilizar librerias de terceros se deben tener en cuenta los archivos de definiciones "*.d.ts" o Typings
Ejm: 
@types/express (Usar express)
@types/jquery (Usar JQuery)

- Un type y una interface son simliares, la diferencia es que un type no se puede extender.
- Definicion de un type:
export type filtrosValidos = 'todos' | 'completados' | 'pendientes';
- Utilizacion de un type:
export const estadoInicial: filtrosValidos = 'todos' as filtrosValidos;

# Operador ??
let x = foo ?? bar();
let x = foo !== null && foo !== undefined ? foo : bar();//Equivalente a la linea anterior

################################################################################################################################################################
########################################################################## RxJS ################################################################################
################################################################################################################################################################

Patron Observer: Notificar cuando suceden cambios
Patron Iterator: Podr ejecutar operaciones secuenciales
Programacion Funcional: Tener funciones con tareas especificas que reciban argumentos y no muten la informacion

# Manejo de Observables, Ejm:

let i = -1;

const obs$ = new Observable((observer) => {
  const interval = setInterval(() => {
	i++;
	observer.next(i);
	if(i === 5) {
	  observer.complete();
	  clearInterval(interval);
	}
	if (i === 2) {
	  //observer.error('i llego a 2')
	}
  }, 1000)
})
//Subscripcion:
obs$.subscribe({
	next: (valor) => console.log(valor),
	error: (err) => console.error(err),
	complete: () => console.info('complete')
});


=== (Operador de equidad mismo tipo mismo valor) 

Los observables calientes comienzan a producir notificaciones independientemente de las suscripciones. Los observables fríos solo producen notificaciones cuando hay una o más suscripciones.

OBSERVABLES FRÍOS
Los Observables "fríos" son aquellos que no emiten valores hasta que haya una suscripción activa, ya que la información es producida dentro del Observable y por tanto solo emiten valores en el momento en que se establece una nueva subscripción, por eso, el ejemplo previo que hemos visto, math.random() devuelve valores diferentes.

OBSERVABLES CALIENTES
Por contra, los Observables "calientes" son aquellos que pueden emitir valores sin que haya ninguna subscripción activa, porque la información del stream se produce fuera del propio Observable. RxJs dispone de algunos Observables ¨calientes¨ y el mejor ejemplo de éstos, es fromEvent que nos permite establecer un Observable sobre cualquier tipo de evento como el click del ratón:

SUBJECTS
Los subjects de RxJs son un tipo de Observable especial que nos permiten realizar diversas tareas como el multicasting, es decir, compartir exactamente el mismo stream de datos con todas las subscripciones sin preocuparnos del tipo de Observable que estamos manejando.

Aparte, hay otra característica de los Subjects que les da una gran versatilidad y es que los Subjects de RxJs son Observables y Observers al mismo tiempo por lo que nos podemos subscribir a un Subject como a cualquier otro Observable, pero además disponen de los métodos next(), error() y complete() que tienen el Observer para emitir sus valores.

# OPERADORES

retry // Reintenta la ejecucion de un observable que tuvo un error, retry(numero de intentos)

take // Establece un limite de emiciones del observable, take(numero de emisiones)

map // Permite transformar los valores emitidos del observable, map(valor => valor + 1)

filter // Permite filtrar que valor emitidor del observable son aceptados y cuales no, filter(valor => (valor % 2) == 0 ? true :  false)

switchMap


firstValueFrom //Permite transformar cualquier Observable en una promise.

combineLatest() //recibe un arreglo de observables. Este operador se utiliza mejor cuando se tienen varios observables de larga duración que dependen entre sí para algún cálculo o determinación.



################################################################################################################################################################
####################################################################### JavaScript #############################################################################
################################################################################################################################################################

-Todos los primitivos se pasan por valor, mientras que los objetos y los arreglos se pasan por referencia.
-Biblioteca de utilidades para JavaScript
https://underscorejs.org/ (Se utiliza en la Seccion 5 del curso de JavaScript)
-// Sintaxis del modo estricto para todo el script
'use strict';
-En esta pagina se puede copiar el codigo JavaScript que construyamos y generar un archivo minify (Ejm. mi-archivo-min.js)
https://javascript-minifier.com/

-Usar webpack
mkdir webpack-demo
cd webpack-demo
npm init -y
-Instalar webpack
npm install webpack webpack-cli --save-dev

WebPack asume que el punto de entrada del proyecto es src/index.js y genera el resultado en dist/main.js minificado y optimizado para producción.
(Este archivo .js lo inyecta en el .html)


-Enlaces de informacion de webpack
https://webpack.js.org/guides/getting-started/
https://webpack.js.org/configuration/

MONTAR HTML EN CARPETA DIST
https://webpack.js.org/loaders/html-loader/
npm install --save-dev html-loader (Instalacion de desarrollo, sirve para mover el html)
npm install --save-dev html-webpack-plugin(Instalacion de desarrollo, sirve realizar una inyeccion de nuestro codigo html en el index que se va a terminar generando)
-En el archivo package.json en las dependencias de desarrollo se pueden ver ambos plugins instalados
-La instalacion se complemeta en el archivo webpack.config.js (module-rules y plugins)

https://webpack.js.org/configuration/dev-server/
npm install --save-dev webpack-dev-server (Sirve para desplegar la aplicacion en un servidor de desarrollo local)
-En el archivo package.json en las dependencias de desarrollo se puede ver el plugin instalado

MONTAR CSS EN CARPETA DIST
https://webpack.js.org/loaders/css-loader/
https://webpack.js.org/loaders/style-loader/
npm install --save-dev css-loader style-loader (Sirven para cargar estilos en mi aplicacion, e inyectar el .css en el .html)
-En el archivo package.json en las dependencias de desarrollo se pueden ver los plugins instalados
-La instalacion se complemeta en el archivo webpack.config.js (module-rules)

npm install --save-dev mini-css-extract-plugin (Sirve para cargar un archivo css de forma global)
-La instalacion se complemeta en el archivo webpack.config.js (module-rules y plugins)

MANEJO DE IMAGENES
npm install file-loader --save-dev (Permite la importacion de imagenes desde directorio Ejm assets)
-La instalacion se complemeta en el archivo webpack.config.js (module-rules)
npm install copy-webpack-plugin --save-dev (Permite copiar y mover recursos estaticos como imagenes de un directorio Ejm assets)
-La instalacion se complemeta en el archivo webpack.config.js (plugins)

EN MODO PRODUCCION
npm install --save-dev css-minimizer-webpack-plugin terser-webpack-plugin (Permite minimizar archivos css)
-En el archivo package.json en las dependencias de desarrollo se pueden ver los plugins instalados
-La instalacion se complemeta en el archivo webpack.config.js (optimization)

INSTALACION DE BABEL PARA LA COMPATIBILIDAD CON NAVEGADORES DE VERSIONES ANTERIORES
https://babeljs.io/setup
npm install --save-dev babel-loader @babel/core
-La instalacion se complemeta en el archivo webpack.config.js (module-rules)
Create babel.config.json configuration file
npm install @babel/preset-env --save-dev

-El método map() crea un nuevo array con los resultados de la llamada a la función indicada aplicados a cada uno de sus elementos.
var doubles = numbers.map(function(x) {
   return x * 2;
});
-El método filter() crea un nuevo array con todos los elementos que cumplan la condición implementada por la función dada.
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
const result = words.filter(word => word.length > 6);
-El método JSON.stringify() convierte un objeto o valor de JavaScript en una cadena de texto JSON.
-El método JSON.parse() analiza una cadena de texto como JSON, transformando opcionalmente el valor producido por el análisis.


# Accediendo a las propiedades de un objeto, hay 3 formas:
- object.property
- object['property']
- const { property } = object


# Definiendo un alias para una propiedad
- const { identifier: aliasIdentifier } = expression;


# Llamando peticiones http en simultaneo

const fileUploadPromises = [];
for (const file of files) {
	fileUploadPromises.push(fileUpload(file)) // fileUpload internamente llama un API Rest.
}
const photosUrls = await Promise.all(fileUploadPromises); // Promise.all se cumple cuando todas las promesas del iterable dado se han cumplido, o es rechazada si alguna promesa no se cumple. 


# Crear una promesa, Ejm:

const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});

await myPromise;

- Las promesas deben ser esperadas con el await (no olvidar que esta palabra reservada se debe utilizar dentro de una funcion marcada con async)

const promesa = new Promise( (resolve, reject) => {
  if(false) {
	resolve('Hola Mundo')
  } else {
	reject('Algo salio mal')
  }
})

promesa.then((mensaje) => {
  console.log(mensaje);
}).catch((err) => console.log('Ocurrio un error', err));

console.log('Fin del Init');


# Delete
- El operador delete de JavaScript remueve una propiedad de un objeto; si no se mantienen más referencias a la misma propiedad, eventualmente se libera automáticamente. Ejm:
const newData = {...actShoppingCart};
delete newData[product.id]; //product.id es una propiedad computada del objeto 
return newData;


# Clonar objetos
let objClone = { ...obj }; // Operador spread (...)


# Copiar arreglos
let arr2 = [...arr];


# return
- Nunca devuelva algo en una nueva línea sin usar paréntesis. Esta es una peculiaridad de JavaScript y el resultado será indefinido. Trate de usar siempre paréntesis cuando devuelva algo en varias líneas.
function foo() {
    return 
      1;
}
function boo() {
    return (
      1
    );
}
foo(); --> undefined
boo(); --> 1


# Negaciones
!null = true
!undefine = true
!''= true

################################################################################################################################################################
######################################################################### Angular ##############################################################################
################################################################################################################################################################

Desde Angular v17, por defecto los proyectos trabajan sin módulos (module-less)
Pero para trabajar de forma tradicional:
ng new <nombre de la aplicación> --standalone false


#####Instalacion#####

#Instalar Angular-cli:
npm install -g @angular/cli
#Para reconstruir un proyecto y generar la carpeta de los modulos del mismo (Ubicarse en el directorio raiz donde estan los fuentes)
npm install
#Para instalar la libreria de internacionalizacion para Angular (i18n).
npm install @ngx-translate/core @ngx-translate/http-loader rxjs --save
#Para instalar libreria para manejo de fechas (moment)
npm install moment --save


#####Estilos Animados CSS#####
De la pagina https://animate.style/ copia la ruta de css
Ejm:
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" />
Y pegarla en el archivo index.html en la seccion correspondiente


#####Comandos Trabajar#####

#Crear proyecto
>npm create vite
>npm install
>npm run dev //Para correr el proyecto

#Crear nuevo proyecto angular
ng new mi-app
#Generar nuevo modulo
ng generate module mi-app
ng generate module mi-app --routing (Esta instruccion genera el archivo xxx.module.tx y el xxx-routing.module.ts)
ng generate module app-routing --flat --module=app (Esta instruccion genera el xxx-routing.module.ts y actualiza el archivo xxx.module.tx)
#Generar nuevo componente
ng generate component mi-app/componentxxx
#Generar nuevo servicio
ng generate service mi-app/services/servicexxx (Los servicios son singleton y quedan disponibles para toda la aplicacion, solo se deben inyectar donde se necesiten)
#Generar nuevo pipe
ng generate pipe mi-app/pipes/pipexxx
#Generar Guard (Servicio de Proteccion de rutas)
ng generate guard mi-app/guards/guardxxx
#Generar Directiva
(Ejemplo)
ng generate directive shared/directives/errorMsg --skiptTest 
El anterior comando crea la directiva en la ubicacion dada y actualiza las declaraciones del modulo correspondiente.
#Subir la aplicacion
ng serve -o
#Subir la aplicacion con proxy para consumir API local (Tener en cuenta crear el archivo proxy.conf.json y modificar el package.json)
Ejm proxy.conf.json:
{
  "/ApiCol/*":{
    "target":"http://localhost:7001",
    "secure":false,
    "logLevel": "debug"
  }
}
package.json
"start": "ng serve --proxy-config proxy.conf.json"
Ahora si en consola ejecutar:
ng serve --proxy-config proxy.conf.json
(No olvidar hacer los llamados en el servicio desde la ruta raiz configurada, Ejm: this.http.get('/ApiCol/Rest/ListAll/getAsignaturas'))
#Generar build de produccion
ng build
#Generar build de desarollo
ng build --configuration=development

#Si se configuran build por ambiente en el package.json y en el angular.json, se puede ejecutar en consola npm run build:develop o npm run build:master
etc, segun el ambiente que se quiera generar:
Ejm en el package.json:
"scripts": {
	"ng": "ng",
	"start": "ng serve",
	"build": "ng build",
	"watch": "ng build --watch --configuration development",
	"test": "ng test",
	"build:develop": "ng build --configuration=develop --output-hashing=all --base-href=/ComercialProtectionOrder/",
	"build:release": "ng build --configuration=release --output-hashing=all --base-href=/ComercialProtectionOrder/",
	"build:preprod": "ng build --configuration=preprod --output-hashing=all --base-href=/ComercialProtectionOrder/",
	"build:master": "ng build --configuration=master --output-hashing=all --base-href=/ComercialProtectionOrder/"
},
Ejm en el angular.json:
"configurations": {
	"master": {...},
	"release": {...},
	... etc
}

#####NOTAS SOBRE ANGULAR#####

# NUEVO: DETECCCION DE CAMBIOS DE ANGULAR
- Se debe trabajar ahora con zoneless en lugar de zone js.
- Se debe agregar en el app.config el provider:
providers: [
    ...
    provideZonelessChangeDetection(),
	...
]




- Para usar *ngIf, *ngFor, pipes, se debe importar el modulo CommonModule
- Para usar el evento ngSubmit en formularios se debe importar el modulo FormsModule (FormModule evita el refresh de la pagina, se utiliza para la aproximacion de formularios por template)
- Angular's two-way binding syntax is a combination of square brackets and parentheses, [()]. 
The [()] syntax combines the brackets of property binding, [], with the parentheses of event binding, (), as follows.
- Para definir variables de entorno se hace en el archivo enviroment.ts (Desarrollo) - enviroment.prod.ts (Produccion)
- LA NUEVA SINTAXIS para definir variables de entorno es: ng g environments y esto genera 2 archivos
environment.ts(produccion) environment.development.ts(desarrollo)

En el archivo tsconfig.json se puede hacer la siguiente configuracion para darle un alias a la URL del environment a utilizar y no tener algo como (../../../ ....)
  "compilerOptions": {
    "baseUrl": ".",
    "paths" : {
      "@environments/*": ["src/environments/*"]
    },
quedando el import mucho mas limpio: import { environment } from '@environments/environment';

- Uso de @ViewChild para acceder a algun componente: A template reference variable as a string (e.g. query <my-component #cmp></my-component> with @ViewChild('cmp'))
public txtTagInput! : ElementRef<HTMLInputElement>;
- LA NUEVA SINTAXIS para acceder a un componente es:
nombreVariable = viewChild<ElementRef<T>>('referenciaLocalEnElHtml');//viewChild es una señal
Ejm: scrollDivRef = viewChild<ElementRef<HTMLDivElement>>('groupDiv');

- Se puede colocar una referencia local en un componente input para luego acceder a el, ejm:
    <input type="text"
    class="input input-bordered w-full max-w-xs"
    placeholder="Buscar heroe"
    #txtSearch
    (input)="searchQuery.set(txtSearch.value)"> // searchQuery es una señal que recibe el valor del input por medio de la referencia local txtSearch
	

- HttpClientModule se utiliza para hacer peticiones http
- LA NUEVA SINTAXIS para utilizar peticiones http es: http = inject(HttpClient);
- En el archivo app.config.ts adicionar el provider: provideHttpClient(withFetch());



- Variable de plantilla #
Ejm:
	<input #phone placeholder="numero telefonico" />
	<button (click)="callPhone(phone.value)">Call</button>
- El decorador @Input es para enviar valores desde un componente padre a un componente hijo:
  @Input()
  public characterList: Character[] = [
    {
      name:' Trunk',
      power: 20000
    }
  ]
- Los @Input se leen como atributos del componente, es decir con [].
- LA NUEVA SINTAXIS para el uso de los input es: nombreVariable = input.required<T>();

- El decorador @Output es para enviar valores desde un componente hijo a un componente padre:
  @Output()
  public onNewCharacter : EventEmitter<Character> = new EventEmitter();
  this.onNewCharacter.emit(this.character);
- Los @Output se leen como eventos del componente, es decir con () y enviando el argumento $event, Ejm:<app-dbz-add-character(onNewCharacter)="onNewCharacter($event)"></app-dbz-add-character>
- LA NUEVA SINTAXIS para el uso de los output es: nombreVariable = output<T>();
- Se puede usar esta sintaxis en el html si se queire emitir el valor de una nombreVariable.emit(txtSearch.value)


# Pipes
- Los pipes se pueden encadenar y se ejecutan de izquierda a derecha.
- Un Pipe impuro funciona exactamente igual que uno "normal", solo que son llamados en cada cambio del ciclo de detección, un click, el foco, el cambio del input etc, lo que significa que los datos que se muestren por pantalla van a estar siempre actualizados, cosa que puede no pasar con un Pipe "puro".
Para convertir un Pipe normal en uno impuro, simplemente añadimos "pure: false" dentro del objeto de su anotación:
@Pipe({
  name: 'filtroCompletado',
  pure: false //true esta por defecto
})

@Pipe({
  name: 'filtroCompletado'
})
Ejm uso:
<app-todo-item *ngFor="let todo of todos | filtroCompletado" [todo]="todo"></app-todo-item>

@Pipe({
  name: 'filtroTodo'
})
export class FiltroPipe implements PipeTransform {
  transform( todos: Todo[], filtro: filtrosValidos): Todo[] {
    return todos;
  }
}
Ejm uso pasando parametro:
<app-todo-item *ngFor="let todo of todos | filtroTodo:filtroActual" [todo]="todo"></app-todo-item>
NUEVA SINTAXIS
Los pipes deben importarse en el componente para ser utilizados
imports: [LowerCasePipe, UpperCasePipe, TitleCasePipe, DatePipe, ... ]

Pipes Personalziados:
- El metodo transform(value: string) recibe como argumento el valor a tratar por el pipe y los demas argumentos que se envien (si aplica).
transform(value: string) -> <div class="stat-value">{{ name() | toggleCase }}</div>
transform(value: string, upper: boolean) -> <div class="stat-value">{{ name() | toggleCase: false }}</div>



#Internacionalizacion
- Para configurar un idioma sebe hacer en el app.config.ts, (el ingles es el idioma por default) ejm español:

import localeEs from '@angular/common/locales/es';
import { registerLocaleData } from '@angular/common';

registerLocaleData(localeEs, 'es');
export const appConfig: ApplicationConfig = {
  providers:[
              ...
              {
                provide: LOCALE_ID,
                useValue: 'es'
              }
  ]
};



#Content Projection
- Permite projectar codigo desde el componente padre al componente hijo
padre.html con la etiqueta ng-content:

page-component.html (padre)
<app-card title="i18nSelectPipe"> <!-- app-card es el componente hijo -->
	<p>Hola mundo desde el padre</p>
	<button class="btn btn-primary">Click me</button>
	...
</app-card>

card.component.html (hijo)
<div class="card-body">
    <h2 class="card-title mb-2">{{ title() }}</h2>
    <ng-content></ng-content>
</div>

<!-- El <ng-content></ng-content> mostrara las siguientes etiquetas y todo el codigo que este dentro de <app-card></app-card>
<p>Hola mundo desde el padre</p>
<button class="btn btn-primary">Click me</button>
...
-->


# Lazy Load
- Para el lazy load se deben crear archivos de rutas por modulos e importarlos en dicho modulo y en el archivo de rutas principal hacer el llamado a los hijos (es decir a los diferentes modulos) con:
loadChildren: () => import ('./countries/countries.module').then( m => m.CountriesModule)
- LA NUEVA SINTAXIS 
- Para hacer el loadChildren es: loadComponent: () => import('./gifs/pages/dashboard-page/dashboard-page.component') (La clase asociada al componente debe ser marcada con default, Ejm: export default MiClase {...})
- Tambien se pueden asociar rutas asi:
	loadChildren: () => import('./reactive/reactive.routes').then(m => m.reactiveRoutes)
	loadChildren: () => import('./auth/auth.routes') //Se debe exportar por default la variable de rutas del archivo auth.routes (export default authRoutes;)

- Para enviar argumentos dinamicos por una URL se debe usar :nombreVariable :
{
	path: 'history/:query',
	...
}
- Se puede acceder a un argumento dinamico mediante la inyeccion de ActivatedRoute:
nombreVariable = inject(ActivatedRoute).params; //Esto devuelve un Observable
*Revisar sintaxis de manejo de rutas de la app de paises*



# Guard (Proteccion de rutas en Angular)
- Se deben crear los guard necesarios con el comando correspondiente e implementar los metodos canLoad(manejo de lazy load) canActivate(permite controlar si sea activa o no, una ruta).
- El metodo canLoad solo restringe que se pueda cargar un modulo, si se carga una primera vez, éste podria ser accedido. 
Por lo anterior se deberia implementar tambien el metodo canActivate.
- Se deben agregar en el o los routin.module donde se tengan definidas las rutas de la aplicacion y que se desean proteger
 Ejm:..
	{
		path: 'welcome',
        component: WelcomeComponent,
        canActivate:[AuthGuard]
	}..


# Router
- El manejo de rutas se hace en un modulo en la raiz de la aplicacion el cual se debe importar al modulo principal o en nuevas versiones de angular al componente.
- Para mostrar las paginas definidas en las rutas se hace con <router-outlet></router-outlet>
- Para accecer a una de la rutas creadas desde un enlace (<a routerLink='auth/login'>...</a>) se puede hacer con:
routerLink


# Formularios Por Template
- Se debe importar el modulo FormModule.
- Se trabaja con el objeto NgForm.
- Se hace referencia al formulario con una referencia local (referencia local en el <form #nombreReferencia="ngForm"> ...) utilizando el @ViewChild.
- Los campos deben ir acompañados de los atributos ngModel y name.
- Para controlar las validaciones de este tipo de formularios se debe implementar una directiva personalizada.
- Las directivas personalizadas deben declaradas en el modulo que las contiene (en la parte de las declaraciones).
- Se puede trabajar el ngModel con la sintaxis [()] para establecer y recuperar valores.


# Formularios Reactivos
- Se debe importar el modulo ReactiveFormsModule.
- Se debe crear una propiedad del tipo FormGroup en el componente.
- Se debe colocar el atributo formGroup=nombrePropiedad del paso anterior en el (<form [formGroup]=nombrePropiedad> ...).
- En cada campo del formulario se debe colocar el atributo formControlName, cuyo valor debe concordar con el establecido del lado de TypeScript.
- El FormBuilder es un servicio (como todo servicio debe ser inyectado para usarlo), este objeto permite mapear los campos del formulario.
EJM:
 formBuilder = inject(FormBuilder);
 myForm = this.formBuilder.group({
    name: ['' /*Valor del formulario*/, [] /*Validadores Sincronos*/, [] /*Validadores Asincronos*/], //En los validadores si es solo uno se puede colocar directo, si son varios irian dentro de un array [], Primero se ejecutan los validadores sincronos
    price: [0, ...],
    inStorage: [0, ... ]
 })


- Valid: Para validaciones del formulario
- Pristine: True si el formulario no se ha tocado desde q se sirvio al usuario, false si se cambia algun valor del formulario
- Touched: El usuario ha tocado o no el formulario, true si lo toco, false si no.
- Value: Valor del formulario (valores de los campos)


# Ciclo de Vida
- constructor() Se ejecuta cuando angular abre o instancia un componente
- Al cargarse un componente primero se ejecuta el constructor y luego el ngOnInit
- El ngOnDestroy se dispara en el caso de mostrar o no un componente con un *ngIf
- El ngOnChange se dispara al pasar valores por medio de un @Input de un componente padre a un hijo, el ngOnChange funciona como interceptor de una propiedad decorada con @Input. Asi mismo, los cambios de una propiedad decorada con @Input puede ser interceptada con un setter.



# Directivas Personalizadas
- Permiten extender la funcionalidad de un componente HTML
- Se puede revisar la directiva de popup creada en el curso Udemy-MicroserviciosSpringBoot_Angular14
- @HostListener es un metodo decorador usado para escuchar y manejar eventos del DOM


# Directivas Estructurales
- No se pueden usar varias directivas estructurales en el mismo elemento; si necesita aprovechar más de una directiva estructural, se recomienda utilizar un <ng-container>
- *ngIf
- *ngFor
- [ngSwitch]
	*ngSwitchCase
	*ngSwitchDefault 
- El <ng-container> de Angular es un elemento de agrupación que no interfiere con los estilos o el diseño porque Angular no lo coloca en el DOM.
- Usar <ng-container> cuando no haya un solo elemento para alojar en la directiva.
Ejm:
<ul>
  <ng-container *ngFor="let item of items">
    <li *ngIf="item.isValid">
      {{ item.name }}
    </li>
  </ng-container>
</ul>


# Directivas de atributos
- [ngClass] Adiciona y/o remueve un conjunto de clases CSS.
- [ngStyle]	Adiciona y/o remueve un conjunto de estilos HTML.
- [(ngModel)] Adiciona el two-way data binding a un elemento de un form de HTML


# Interceptores
- Los interceptors en Angular nos brindan un mecanismo para interceptar y/o mutar las solicitudes y respuestas http. No debe confundirse con los Guards. Los interceptors modifican las peticiones del http module.
- Para implementar un interceptor se necesita una clase inyectable que implemente “HttpInterceptor”. La clase debe definir un método “intercept”, el cual toma dos argumentos, req y next, y devuelve un observable de tipo HttpEvent.
- Los interceptors se ejecutan en cada petición que se realiza al servidor, para eso deben estar registrados. Para registrar un interceptor se tiene que proveer en el array de providers: [] en nuestro módulo raíz, por lo general AppModule.
Ejemplos de uso:
	Autenticación
	Añadir cabeceras extras a las peticiones.
	Almacenar un log de las peticiones realizadas por la aplicación.
	Loading Centralizado.
	Manejador de Errores.
	Notificaciones
	Debug de las respuestas recibidas. etc..

# Inyeccion de Dependencias
- Una clase anotada con  @Injectable es para permitir que la clase se puede inyectar.
@Injectable()
class HeroService {}

- Una dependencia se puede proporcionar en varios lugares:
	1. A nivel componente: (En este caso se obtiene una nueva instancia del servicio con cada nueva instancia del componente)
	@Component({
	  selector: 'hero-list',
	  template: '...',
	  providers: [HeroService]
	})
	class HeroListComponent {}	
	2. A Nivel de Modulo: (En este caso, la misma instancia del servicio está disponible para todos los componentes, directivas y pipes declarados en este NgModule)
	@NgModule({
	  declarations: [HeroListComponent]
	  providers: [HeroService]
	})
	class HeroListModule {}
	3. A Nivel raiz de la aplicacion: (En este caso se crea una única instancia compartida de HeroService y la inyecta en cualquier clase que lo solicite)
	@Injectable({
	  providedIn: 'root'
	})
	class HeroService {}
- La forma más común de inyectar una dependencia es declararla en un constructor de una clase
- LA NUEVA SINTAXIS para inyeccion de dependencias es: nombreVariable = inject(T);
- Con la nueva sintaxis se injectan los servicios en angular.


# Señales
- Las señales trabajan con Zoneless en lugar de ZoneJS
- Los metodos de las señales vienen de angular/core
- Se define una señal con signal
- Se actualiza una señal con update o set (update es para considerar el valor que tenia la señal, mientras set no lo considera)
- Ejm de sintaxis:
nombreSenal: WritableSignal<T> = signal(T);//Equivalente
nombreSenal = signal<T>(T);//Equivalente

- Las señales computadas son señales de solo lectura que derivan su valor de otras señales

const count: WritableSignal<number> = signal(0);
const doubleCount: Signal<number> = computed(() => count() * 2);

La señal doubleCount depende de la señal count. Cada vez que count se actualiza, Angular sabe que doubleCount también debe actualizarse.
- Se puede convertir un Observable en una señal con toSignal, ejm:
query = toSignal(
    inject(ActivatedRoute).params.pipe(map((params) => params['query']))
);

- Se puede usar la función signal para mantener un estado. A veces, este estado depende de otro.
linkedSignal(() => ) funciona de forma similar a signal, con una diferencia clave: en lugar de pasar un valor predeterminado, se pasa una función de cálculo, igual que computed. 
Cuando el valor del cálculo cambia, el valor de linkedSignal cambia al resultado del cálculo. Esto ayuda a garantizar que linkedSignal siempre tenga un valor válido.



# Uso de efectos
- Se define un efecto con effect
- Asi como los metodos para el manejo de señales, los efectos vienen de angular/core
- La sintaxis para escribir un efecto debe ser como la siguiente:
saveToLocalStorage = effect(() => {
  console.log(`The length is: `);
})


#onCleanup 
// Tener en cuenta su utilizacion para evitar fugas de memoria en los efectos
debounceEffect = effect((onCleanup) => {
	const value = this.inputValue();

	const timeOut = setTimeout(() => {
	  this.value.emit(value);
	}, 1000);

	onCleanup(() => {
	  clearTimeout(timeOut);
	})
})

//Terminar una subscripcion
onFormChanged = effect((onCleanup) => {
    const regionSubscription = this.onRegionChanged();// onRegionChanged es una susbcripcion
    const countrySubscription = this.onCountryChanged();// onCountryChanged es una susbcripcion

    onCleanup(() => {
      regionSubscription.unsubscribe();
      countrySubscription.unsubscribe();
    });
  });




#####TIPS#####
- Para crear clase que represente modelo JSON (response de un servicio rest) utilizar:
https://app.quicktype.io/
- Cuando sale un error de tipo read-only property, una posible solucion es:
variable.propiedad = 'valor'; //posible error read-only
(variable as any).propiedad = 'valor';

- Para establecer un color aleatorio: 
const color = "#xxxxxx".replace(/x/g, y=>(Math.random()*16|0).toString(16));

- JWT (JSON WEB TOKEN, Forma de autenticacion pasiva) https://jwt.io/

- Iconos: 
https://fontawesome.com/icons
https://cdnjs.com/libraries/font-awesome
- Agregar al HTML
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha512-Evv84Mr4kqVGRNSgIGL/F/aIDqQb7xQ2vcrdIwxfjThSH8CSR7PBEakCr51Ck+w+/U6swU2Im1vVX0SVk9ABhg==" crossorigin="anonymous" referrerpolicy="no-referrer" />



####Para vincular angular en Java#####
Opcion 1:
- Compilar o generar build correspondiente del proyecto de angular
- Copiar los archivos del punto anterior y colocarlos en el webapp del proyecto web java (WAR)
- Modificar el valor del tag <base href="/"> por <base href="./"> del archivo index.html
- Generar componente Java y desplegar en servidor de aplicaciones y listo
Opcion 2:
- Compilar o generar build correspondiente del proyecto de angular
- Colocar al mismo nivel de los archivos angular generados tras el build, el directorio WEB-INF
- Verificar el context root en el archivo weblogic.xml presente en el directorio WEB-INF asi como en el index.html en el tag <base href= ....>
- Para evitar problemas de direccionamiento (error 404) en el archivo web.xml presente en el directorio WEB-INF, colocar la pagina de bienvenida, como de error, apuntando al index.html
- Ubicarse en el nivel del punto anterior y ejecutar el comando: jar cvf nombre_war-war.war .  
- Desplegar el war generado en el servidor de aplicacion de java correspondiente
- De ser necesario habilitar plugin en navegador para el manejo de CORS o configurar el CORS en el backend


#####Instalacion de Angular Material#####
https://material.io
https://material.io/design/color/the-color-system.html  //Para personalizar el color del tema
https://material.io/resources/color  //Herramienta para seleccion de colores
ng add @angular/material
npm i @angular/localize


#####Instalacion de Tailwind#####
https://tailwindcss.com/docs/installation/framework-guides/angular
>npm install tailwindcss @tailwindcss/postcss postcss --force
Agregar en src/styles.css:
@import "tailwindcss"; 




#####Instalacion de DaisyUI#####
https://daisyui.com/docs/install/
>npm i -D daisyui@latest
- Agregar en el archivo src/styles.css:
@import "tailwindcss";
@plugin "daisyui";

- Para Definir Tema en el archivo index.html:
@plugin "daisyui" {
  themes: light --default, dark --prefersdark, retro;
}
<html lang="en" data-theme="retro">


- Para tailwind y daisyui no olvidar agregar el archivo .postcssrc.json con:
{
  "plugins": {
    "@tailwindcss/postcss": {}
  }
}




#####Instalacion de Angular-flex##### (Para ubicacion de elementos y manejo del Responsive)
Dentro del proyecto ejecutar
npm i @angular/flex-layout
npm i -s @angular/flex-layout @angular/cdk
- importar el modulo correspondiente FlexLayoutModule


#####Instalacion de PrimeNG#####
npm install primeng --save
npm install primeicons --save
npm install primeflex --save

-Instalar para virtual scroll
npm install @angular/cdk --save

Tener en cuenta:
Modificar el archivo angular.json
Seccion assets van los recursos estaticos de la aplicacion
Seccion styles colocar los estilos que usara PrimeNg:
"node_modules/primeicons/primeicons.css"
"node_modules/primeng/resources/themes/saga-blue/theme.css"
"node_modules/primeng/resources/primeng.min.css"
"node_modules/primeflex/primeflex.css"
reiniciar terminal (ng serve)
- Para los componentes que utilizan animaciones se debe importar el modulo BrowserAnimationModule


#####Instalacion Para Manejo de Graficas#####
npm install --save ng2-charts
npm install --save chart.js


#####Instalacion de FileSaver para guardar archivos#####
npm install file-saver --save
npm install @types/file-saver --save


#####Instalacion de CryptoJS para encriptaciones#####
npm install crypto-js --save
npm install @types/crypto-js --save


#####Instalacion de Firebase#####
>npm install firebase @angular/fire
- En el modulo donde se vaya a registrar colocar:
	AngularFireModule.initializeApp(environment.firebase),
	provideFirebaseApp(() => initializeApp(environment.firebase)),
	provideFirestore(() => getFirestore())


####Redux con Angular (NgRx)#####
https://ngrx.io/guide/store
>npm install @ngrx/store --save //Es el módulo principal con el administrador del estado centralizado y reactivo.
Utilizacion	
	1.Generar archivos xxx.actions.ts y xxx.reducer.ts
	2.En el modulo donde se vaya a utilizar, importar el: StoreModule
	StoreModule.forRoot({contador: contadorReducer}) // Es un ejm de nombre de reducer contadorReducer
	3.En el constructor del componente donde se deseen llamar acciones se puede inyectar el objeto Store con: private store: Store<AppState> //Store define un generico que representa el objeto state, este objeto debe tener una propiedad con el mismo nombre definido en el StoreModule.forRoot({contador: contadorReducer}) es decir, en este ejm seria contador.
	interface AppState {
	  contador : number
	}
	4.Se puede suscribir al objeto Store para ver los cambios de estado:
	this.store.subscribe( state => {
      console.log(state);
    })
	con select se puede seleccionar un no en especifico
	this.store.select('contador').subscribe( state => {
      console.log(state);
    })
	5.Hacer el dispacth correspondiente, ejm this.store.dispatch( accion )

https://ngrx.io/guide/store-devtools/install (Store Devtools)
>npm install @ngrx/store-devtools --save
Utilizacion:
	1.En el modulo donde se vaya a utilizar, importar el StoreDevtoolsModule:
	StoreDevtoolsModule.instrument({
      maxAge: 25, // Retains last 25 states
      logOnly: environment.production, // Restrict extension to log-only mode
      autoPause: true, // Pauses recording actions and state changes when the extension window is not open
    }),

- Lazy del store:
StoreModule.forFeature('ingresosEgresos', ingresoEgreso.ingresoEgresoReducer) 

- Los Efectos:
Estos escuchan acciones
Permiten la comunicacion fuera del ecosistema de angular
>npm install @ngrx/effects --save


>npm i @ngrx/effects //Los reductores son funciones puras sin efectos colaterales. Este módulo es la solución para comandos asíncronos.
>npm i @ngrx/entity //Es otro módulo opcional con ayudas y plantillas de NgRX.
>npm i ngx-image-cropper  //Mantenimiento de imagenes
>npm i rxfire  //Firebase + Rxjs

#REDUX
https://es.redux.js.org/
- Toda la data de la aplicacion se encuentra en una estructura previamente definida
- Toda la informacion se encontrará almacenada en un unico lugar llamado STORE
- El STORE jamas se modifica de manera directa
- Interacciones de usuario y/o codigo dispara acciones
- El valor actual de la informacion de la aplicacion se llama STATE
- Un nuevo estado es creado en base a la combinacion del viejo estado y una accion por una funcion llamada REDUCER
- Si se dese utilizar redux en una aplicacion javascript pura se puede utilizar la libreria redux
>npm i redux



#####Despligue de una app angular en apache#####
- Generar el build correspondiente de la app de angular
- En apache ubicar el directorio donde van las paginas (Ejm C:\Apache24\htdocs) y pegar los archivos generados en el build anterior
- Modificar el valor del tag <base href="/"> por <base href="./"> del archivo index.html
- En el archivo httpd.conf habilitar los modulos (LoadModule headers_module modules/mod_headers.so y LoadModule rewrite_module modules/mod_rewrite.so)
- Copiar lo siguiente en el archivo httpd.conf en la seccion <Directory "${SRVROOT}/htdocs">
	RewriteEngine On
	RewriteBase /
	RewriteRule ^index\.html$ - [L]
	RewriteCond %{REQUEST_FILENAME} !-f
	RewriteCond %{REQUEST_FILENAME} !-d
	RewriteRule . index.html [L]
	
	Header add Access-Control-Allow-Origin "*"
- De ser necesario habilitar plugin en navegador para el manejo de CORS
	

################################################################################################################################################################
########################################################################## React ###############################################################################
################################################################################################################################################################

1. En react todo empieza con un functional component, el cual es una funcion. 
2. Existen dos tipos de componentes, en base a funciones y los que son en base a clases. Se recomienda trabajar con esto (funciones) y no con clases.
3. Los componentes se deben nombrar con Upper Camel Case por estandar


# Instalaciones necesarias
- Extenciones de Chrome
	1. React Developer Tools
	2. Redux DevTools
	
- Extensiones de VSC
	1. ES7+ React/Redux
	2. Simple React Snippets
	3. Auto Rename Tag


# Creacion de proyecto React con Create (CRA WebPack):

- Comando para crear una app React: 
>npx create-react-app nombre_proyecto (Para crearlo con javascript)
>npx create-react-app nombre_proyecto --template typescript (Para crearlo con typescript)
>npm start (Para subir la aplicacion)
- Con este esquema de creacion no ejecutar el comando eject
- En el index.html en el id="root" es donde queda incrustada toda la aplicacion


# Creacion de proyecto React con Vite:

- Comando para crear una app React: 
>npm create vite
>npm install Para instalar los paquetes ya que Vite no lo hace automaticamente
>npm run dev para subir la aplicacion


-Cuando se requiera devolver un conjunto de elementos que estan en el mismo nivel jerarquico en un functional component, se pueden envolver con un Fragment, ya que siempre se debe devolver un nodo padre, o encerrados con <> ... </>
-En jsx se pueden tener expresiones de javascript, excepto colocar un objeto directamente o un boolean, si se desea hacer esto, se deberia usar el JSON.stringify( obj ) para serializarlo y poderlo mostrar, sino, se genera un error.

- Una propiedad numerica se envia desde el padre al hijo con { 123 }
- Para el uso de PropTypes en CRA no se necesita hacer ninguna instalacion, con vite si se requiere ejecutar:
npm install prop-types
Ejm de su utilizacion, (Por fuera del functional component al final):
FirstApp.propTypes = {
	title:PropTypes.string.isRequired,
	subTitle:PropTypes.number
} 
- Para el uso de defaultProps 
Ejm de su utilizacion, (Por fuera del functional component al final):
FirstApp.defaultProps = {
	title:'No hay titulo',
	subTitle:'No hay subtitulo'
} 


# Eventos
https://es.reactjs.org/docs/events.html
- Cuando se definan eventos tener en cuenta que empiecen con el rpefijo "on"


# Hooks
- Empiezan por 'use'... Ejm: useState
- https://es.reactjs.org/docs/hooks-intro.html
- No se deben poner condicionalmente los hooks
- Un Hook es una función especial que permite “conectarse” a características de React. Por ejemplo, useState es un Hook que te permite añadir el estado de React a un componente de función.
- Un Hook es una funcion que regresa algo y que puede recibir argumentos o no, asi se puede crear un hook personalizado para agrupar logica.

- useState
	El único argumento para el Hook useState() es el estado inicial, puede ser un primitivo, un array, un objeto
	Devuelve una pareja de valores: el estado actual y una función que lo actualiza
	useState si hace un re-renderizado del componente.
	
- useEffect
	Recibe 2 argumentos, 1 una funcion callback de lo de se desea ejecutar, y 2 una lista de dependencias (opcional) que son las condiciones para volver a ejecutar el callback, si el 2 argumento se deja vacio el hook se dispara solo la primera vez q se crea el componente.
	Al usar este Hook, le estamos indicando a React que el componente tiene que hacer algo después de renderizarse. React recordará la función que le hemos pasado (nos referiremos a ella como nuestro “efecto”), y la llamará más tarde después de actualizar el DOM. En este efecto, actualizamos el título del documento, pero también podríamos hacer peticiones de datos o invocar alguna API imperativa.
	
- useLayoutEffect
	Es idéntico a useEffect, pero su principal diferencia clave es que se activa sincrónicamente después de todas las mutaciones del DOM

- useRef
	Devuelve un objeto ref mutable cuya propiedad .current se inicializa con el argumento pasado (initialValue). El objeto devuelto se mantendrá persistente durante la vida completa del componente.
	Puede que estes familiarizado con las referencias principalmente como un medio para acceder al DOM. Si pasas un objeto de referencia a React con <div ref={myRef} />, React configurará su propiedad .current al nodo del DOM correspondiente cuando sea que el nodo cambie.
	Sin embargo, useRef() es útil para más que el atributo ref. Es conveniente para mantener cualquier valor mutable que es similiar a como usarías campos de instancia en las clases.
	useRef no hace un re-renderizado del componente.

- useMemo
	Devuelve un valor memorizado.
	Pasa una función de “crear” y un arreglo de dependencias. useMemo solo volverá a calcular el valor memorizado cuando una de las dependencias haya cambiado.
	const hero = useMemo(() => getHeroById(id), [id]);
	
	const parsedDeadline = useMemo(() => {
        console.log('memo');
        return Date.parse(deadline);
    }, [deadline]);

- useCallback
	Devuelve un callback memorizado.
	Pasa un callback en línea y un arreglo de dependencias. useCallback devolverá una versión memorizada del callback que solo cambia si una de las dependencias ha cambiado.
	
- userReducer
	- Una alternativa a useState. Acepta un reducer de tipo (state, action) => newState y devuelve el estado actual emparejado con un método dispatch. (Si está familiarizado con Redux, ya sabe cómo funciona).
	- useReducer a menudo es preferible a useState cuando se tiene una lógica compleja que involucra múltiples subvalores o cuando el próximo estado depende del anterior. useReducer además te permite optimizar el rendimiento para componentes que activan actualizaciones profundas, porque puedes pasar hacia abajo dispatch en lugar de callbacks.
	- const [authState, dispatch] = useReducer(authReducer, [], init);//1-Reducer (funcion), 2-, 3-Inicializador (funcion)
	- El argumento action del reducer tiene los valores del type (accion a ejecutar) y el payload (valor o valores)
	
	
# React.memo 
- Es un componente de orden superior.
- React.memo() es un HOC que permite memorizar un componente en memoria, esto quiere decir:
	React toma nuestro componente que envolvemos con React.memo, lo renderiza y lo almacena en memoria.
	//Declaración React.memo(<Component />, ()=>{})
	Ahora, antes del siguiente render de nuestro componente memorizado, React evaluará si las propiedades han cambiado, si existe un cambio, lo volverá a renderizar y grabar en memoria, de lo contrario, utilizará el que esta en la memoria.


# Functional Components
- Nunca se deberian llamarse funciones directamente dentro de un functional component, ya que cada vez q se renderice estaria llamando x funcion.
- Cada vez que react detecta un cambio en el componente lo vuelve a ejecutar para redibujarlo
- En una etiqueta no se pueden aplicar clases con el atributo class, debe usarse className.
- En VSC se puede crear rapidamente el snipet con: escribiendo rafc + tab
- En un elemento personalizado, el nombre del mismo no debe empezar por lowercase


# Compound Component Pattern
- Segmentar un componente en varios componentes mas pequeños
- El componente padre o principal convertirlo en un Higher Component cuyos hijos son los sub-compoenentes creados en el punto anterior
- Revisar seccion 5 del curso de react pro:
<ProductCard product={product}> ----> Componente Padre
  <ProductCard.Image /> ----> Sub-Componentes Hijos
  <ProductCard.Title title={ product.title } />
  <ProductCard.Buttons counter={0} increaseBy={function (value: number): void {
	throw new Error('Function not implemented.');
  } } />
</ProductCard>


# Router (Este es un componente de nivel superior - Higher Component)
# Instalacion de React Router
>npm install react-router-dom@6
- Se debe importar: import { BrowserRouter } from "react-router-dom";
- Utilizar este higher component en el elemento mas arriba que consideremos de nuestra aplicacion.
	en el main.jsx
	ReactDOM.createRoot(document.getElementById('root')).render(
	  <BrowserRouter>
		<React.StrictMode>
		  <MainApp />
		</React.StrictMode>
	  </BrowserRouter>
	)
- Definir en un archivo functional component las rutas principales de la Aplicacion ejm en un archivo AppRouter.jsx
	<Routes>
        <Route path="login" element={ <LoginPage /> } />
        <Route path="/*" element={ <HeroesRoutes /> } />
	</Routes>
- Utilizar el functional component creado ejm:
	<AppRouter />
- Para navegacion por ejm desde un boton utilizar el hook useNavigate
	const navigate = useNavigate();
	navigate(-1); //-1 Para regresar
- Para navegacion por ejm desde un enlace utilizar <Link>
	<Link to={`/hero/${id}`}>
		Mas...
	</Link>
	
	<NavLink> // Permite determinar si se esta en la ruta dependiendo del path y asi colocar una clase de activo o no
- Para navegacion por ejm desde un redireccionamiento que se desee hacer utilizar <Navigate>
	return <Navigate to={'/marvel'} />
- El hook useParams() permite recibir parametros que vienen en el url, se utiliza al pasar parametros del tipo (/hero/${id}) cuya url se mapea con (/hero/:id)
- El hook useLocation() es como un estado que siempre devuelve su URL actual. Si se cambia la URL, useLocation también se actualizará, se utiliza al pasar parametros de consulta del tipo (?some=search-string)


# Rutas Privadas y Publicas (Este tambien es un componente de nivel superior)
- Crear el higher component o componente de nivel superior (Basicamente un functional component) ejm "PrivateRoute.jsx", pasandole como argumento un children que reseprentaria los hijos que este componente tendria (es decir las rutas privadas que este contendria)
- En este componente se puede validar por ejm si el usuario esta logueado para acceder a las rutas privadas.
- Utilizar este componente, colocarlo envolviendo las rutas que se vayan a dejar privadas o publicas
<Route path="/*" element={
  <PrivateRoute>
	<HeroesRoutes />
  </PrivateRoute>
}/>


# Lazy Load
- Utilizar el metodo lazy de:
import { lazy } from 'react';
- Para trabajar con componentes Lazy, estos deben ser exportados con un export default.
const Lazy1 = lazy( () => import(/* webpackChunkName: "Lazy1" */  '../01-lazy-load/pages/LazyPage1') ); // dejar el comentario para renombrar el chunk
- Se debe envolver el elemento <BrowserRouter> con <Suspense fallback={ <span>Loading...</span> } > //El fallback pueder ser null tambien
- Al trabajar de forma modularizada, los estilos css dentro de un modulo, react les asigna un hash de forma unica.


### Context (Este es un componente de nivel superior - Higher Component)
# Opcion 1 Para Manejo de Contextos:

- Se debe crear en un archivo por ejm "AuthContext.jsx", puede ser dentro de un directorio llamado por ejm "context"
	Con lo siguiente: export const AuthContext = createContext(); // import { createContext } from "react";
- Crear el higher component o componente de nivel superior (Provider) ejm "AuthProvider.jsx", pasandole como argumento un children que reseprentaria los hijos que este componente tendria.
	Con lo siguiente: importar el elemento context creado en el punto anterior
	return (
		<AuthContext.Provider value={{...authState, login, logout }}>
			{ children }
		</AuthContext.Provider>
	);
- Colocar el higher component creado en el elemento mas arriba que consideremos de nuestra aplicacion
	Con lo siguiente: Se toma el componente raiz, ejm MainApp y se reemplaza el fragment por el <AuthProvider> creado en el punto anterior
- Utilizar donde se requiera el useContext... const context = useContext(AuthContext); //Se puede tambien desestructurar
# Opcion 2 Para Manejo de Contextos:
const ProductContext = createContext({});
const { Provider } = ProductContext;
<Provider value={{ ...authState, login, logout }}>
	...
	{ children }
	...
</Provider>
- Utilizar donde se requiera el useContext... const context = useContext( ProductContext ); //Se puede tambien desestructurar


# Reducer
- Es una funcion comun y corriente, por lo general se nombra con el prefijo "todo"
- Debe ser una funcion Pura
- Un reduce no debe tener efectos secundarios 
- No debe realizar tareas asincronas
- Debe retornar siempre un estado nuevo
- No debe llamar a localStorage ni sessionStorage


### Redux ###
- Es un patron para crear nuevos estados basados en reducers.
- Redux Toolkit facilita el trabajo con redux https://redux-toolkit.js.org/
- Install Redux Toolkit and React-Redux
>npm install @reduxjs/toolkit react-redux
	1. Crear el Store
	import { configureStore } from '@reduxjs/toolkit';
	export const store = configureStore({
	  reducer: { ... },
	})
	2. Crear el Provider, es decir proveer el store a los diferentes componentes de react
    <Provider store={store}>
      <App />
    </Provider>
	3. Crear el slice que es una función que acepta un estado inicial, un objeto de funciones de reducción y un "nombre de segmento".
	4. Agregar el slice, en el store:
	export const store = configureStore({
	  reducer: {
		counter: counterSlice.reducer
	  },
	})
	5. Utilizar el store
	useSelector() para seleccionar algo del store
	useDispatch() para ejecutar una accion
	const {miCounter} = useSelector(state => state.miCounter);
	const dispatch = useDispatch();
	<button type="button" onClick={() => dispatch(increment())}>
		Incrementar
	</button>
	6. Solo si aplica
	Cuando usamos un Redux Store básico, lo único que puedes hacer son actualizaciones síncronas sencillas por medio de una acción. Pero si quieres trabajar con lógica asíncrona para interactuar con el Store, necesitarás algo más. Aquí es donde entra redux-thunk. (middleware)
	Paso a paso de un proceso con Redux-Thunk:
		1. Verificar la acción entrante
		Si es una acción regular, redux-thunk no hace nada y la acción es procesada por el reducer del Store.
		
		2. Si la acción es una función
		Redux-thunk la invoca y usa los métodos dispatch y getState y cualquier argumento adicional.
		
		3. Después que la función se ejecute
		El thunk envía la acción, la cual actualizará el estado como corresponde.
		Ejm:
		export const getPokemons = ( page = 0 ) => {
			return async( dispatch, getState ) => {
				dispatch( startLoadingPokemons() );
				const { data } = await pokemonApi.get(`/pokemon?limit=10&offset=${ page * 10 }`);
				dispatch( setPokemons({ pokemons: data.results, page: page + 1 }) );
			}
		}
	

### Creacion de Build ###

>npm run build
- Se genera el directorio dist

- Si se configuran build por ambiente en el package.json, se puede ejecutar en consola >npm run build:develop o >npm run build:prod
etc, segun el ambiente que se quiera generar:
- Ejm en el package.json:
"scripts": {
    "dev": "vite --base=/CalendarApp/", //Configuracion para desarrollo local ejecutando >npm run dev
    "build:develop": "vite build --mode develop --base=/CalendarApp/",
    "build:staging": "vite build --mode staging --base=/CalendarApp/",
	"build:prod": "vite build --mode prod --base=/CalendarApp/",
    "preview": "vite preview"
},
- En el BrowserRouter configurar el basename correspondiente:
<BrowserRouter basename={import.meta.env.BASE_URL}>


### Para vincular react en servidor Java ###

- Compilar o generar build correspondiente del proyecto de react
- Colocar al mismo nivel de los archivos de react generados tras el build, el directorio WEB-INF
- Verificar el context root en el archivo weblogic.xml presente en el directorio WEB-INF
- Para evitar problemas de direccionamiento (error 404) en el archivo web.xml presente en el directorio WEB-INF, colocar la pagina de bienvenida, como de error, apuntando al index.html
- Ubicarse en el nivel del punto anterior y ejecutar el comando: jar cvf nombre_war-war.war .  
- Desplegar el war generado en el servidor de aplicacion de java correspondiente
- De ser necesario habilitar plugin en navegador para el manejo de CORS o configurar el CORS en el backend


# Variables de entoro
- Se deben crear en la raiz del proyecto los archivos .env correspondientes segun los build a tener en cuenta:
.env para desarrollo local
.env.develop
.env.staging
.env.prod (en el .env de produccion colocar la propiedad NODE_ENV=production para generar un build apropiado para produccion y no se genere este mensaje de error:
	(You are currently using minified code outside of NODE_ENV === 'production'. This means that you are running a slower development build of Redux)
- Segun el build que se genere tomara automaticamente el archivo .env correspondiente.


# Archivo de Barril
- Es un archivo agrupador de importaciones, se debe colocar dentro del directorio que contenga varios archivos que son importados, y se debe nombrar como index.js y debe contener los export de cada archivo en cuestion. Ejm: Se tiene el directorio components que contiene:
export * from './Addcategory';
export * from './GifGrid';
export * from './GifItem';
...
Y al hacer la importacion del index.js se hace asi, Ejm: (No hay necesidad de colocar el ./components/index ya que es redundante)
import { Addcategory, GifGrid } from './components';


# CSS
- import  '../styles/custom-styles.css'; // Importacion de una hoja de estilos regular
- import styles from './Button.module.css'; // Importacion de modulos css como styles, clave el nombre del css con la palabra module (.module.css)


# Material UI
- Instalacion:
>npm install @mui/material @emotion/react @emotion/styled
- Colocar fuentes respectivas de material ui, adicionar lo siguiente en el index.html
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
/>
- Colocar iconos, instalarlos mediante:
>npm install @mui/icons-material
- Crear el higher component o componente de nivel superior ejm "AppTheme.jsx", pasandole como argumento un children que reseprentaria los hijos que este componente tendria
- Retornar:
<ThemeProvider theme={theme}>
  <CssBaseline />
  {children}
</ThemeProvider>
- Utilizar en el componente donde se requiera que éste sea envuelto por el componente creado en el punto anterior, ejm:
<AppTheme>
  <AppRouter />
</AppTheme>


# Formik // Para manejo de formularios
>npm install formik --save


# Yup // Es un generador de esquemas de JavaScript para el análisis y la validación de valores.
>npm install -S yup


### PWA ###

- Debe funcionar sobre https
- Se puede trabajar con Workbox:
Instalar:
>npm install workbox-cli --global
>workbox --version
>workbox wizard (seguir el asistente)
>workbox generateSW workbox-config.js
>workbox injectManifest


### Paquetes de terceros ###
>npm install query-string //Para Parse and stringify URL query strings


# Axios para consumo de peticiones http
>npm install axios


# Validador de Strings
>npm install validator


# Para instalar libreria para manejo de fechas (moment)
>npm install moment --save
# Para instalar libreria para manejo de fechas (date-fns)
>npm install date-fns --save
# DatePicker
>npm install react-datepicker --save

# Para instalar libreria para manejo de mensajes (sweet alert)
https://sweetalert2.github.io/
>npm install sweetalert2

# Libreria para generacion de animaciones
https://greensock.com/
>npm install gsap

# Para creacion de modales
>npm install --save react-modal

# MapBox
>npm install --save mapbox-gl
>npm i --save-dev @types/mapbox-gl


# Sitio para subir imagenes o videos
https://cloudinary.com/
https://api.cloudinary.com/v1_1/djpwklufs/upload


# Testing

Instalación y configuracion de Jest + React Testing Library
En proyectos de React + Vite

Instalaciones:
yarn add --dev jest babel-jest @babel/preset-env @babel/preset-react 
yarn add --dev @testing-library/react @types/jest jest-environment-jsdom

Opcional: Si usamos Fetch API en el proyecto:
yarn add --dev whatwg-fetch

Actualizar los scripts del package.json
"scripts: {
  ...
  "test": "jest --watchAll"

Crear la configuración de babel babel.config.js
module.exports = {
    presets: [
        [ '@babel/preset-env', { targets: { esmodules: true } } ],
        [ '@babel/preset-react', { runtime: 'automatic' } ],
    ],
};

Opcional, pero eventualmente necesario, crear Jest config y setup:
jest.config.js
module.exports = {
    testEnvironment: 'jest-environment-jsdom',
    setupFiles: ['./jest.setup.js']
}

jest.setup.js
// En caso de necesitar la implementación del FetchAPI
import 'whatwg-fetch'; // <-- yarn add whatwg-fetch


###############################################################################################################################################################
######################################################################### FIREBASE ############################################################################
###############################################################################################################################################################

https://firebase.google.com/
>npm install firebase
- En la pagina https://firebase.google.com/ crear un proyecto sin hosting y sin google analitics y copiar el codigo de </>
- En la opcion Compilacion seleccionar Firestore Database para crear la base de datos (No Relacional), con las opciones por defecto.
	No olvidar editar las reglas y establecer lo siguiente: allow read, write: if request.auth != null;



###############################################################################################################################################################
########################################################################### HTML5 #############################################################################
###############################################################################################################################################################

Etiquetas estructurales:

- <header>
- <nav>
- <section>
- <article>
- <footer>

Nuevas entradas en formularios

- color, date, datetime, datetime-local, email, month, number, range, search, tel, time, url, week

Nuevos atributos en los tipos de entrada HTML5

- autocomplete, autofocus, list, max, min, multiple, pattern, required, step, placeholder

	
Compatibilidad:

- Para hacer funcionar una aplicacion HTML5 en todos los navegadores que no soportan todas las caracteristicas de HTML5, se pueden utilizar librerias de apoyo:
<script src="scripts/jquery.min.js"></script>
<script src="scripts/modernizr-custom.js"></script>
<script src="scripts/webshim/polyfiller.js"></script>

	
	
###############################################################################################################################################################
############################################################################## CSS3 ###########################################################################
###############################################################################################################################################################

Revisar en primera medida https://caniuse.com/ para temas de compatibilidades

# Metodologia BEM
- BEM (Block, Element, Modifier o Bloque, Elemento, Modificador) es una metodología ágil de desarrollo basada en componentes
- La metodología BEM divide la interfaz de usuario en bloques independientes para crear componentes escalables y reutilizables. Explicamos cómo funciona.
- Bloques (div, section, article, ul, ol, etc.), elementos (a, button, li, span, etc.) y modificadores. Estos últimos se definen de acuerdo a la posterior utilización que haga el desarrollador a cargo.


Prioridades:
#Los estilos se aplican con la siguiente prioridad:
1. Los definidos en el atributo style del elemento HTML
2. Los definidos en el documento HTML <style> ... </style>
3. Los definidos en un archivo de tipo css
4. Tambien considerar que se aplica el estilo mas especifico que exista sobre algun elemento, Ejm:
#saludo h1{ //Se aplica este ya que es mas especifico
	...
}
h1 {
	...
} 
- La prioridad se puede modificar adicionando !important


Elementos en Bloque o Inline:

- Elementos en bloque (default)
	div, p, h1-h6, ul, ol
- Elementos inline (default)
	span, a, b, string, img


Selectores:

#Selector Universal * 
- Aplica a todos los elementos HTML *{...}

#Selector por etiqueta
- h1{...}, p{...}, footer a{...}, etc

#Selectores id
- Se utiliza para especificar el estilo de un elemento unico en la pagina web actual
- Para definir un ID de css se utiliza el operador #
- Se aplica al atributo id en los elementos HTML

#Selectores class
- Se utiliza para especificar el estilo de un grupo de elementos
- Para definir una clase css se utiliza el operador punto (.)
- Se aplica al atributo class en los elementos HTML

#Selectores tipo sibling
- div > p (> Elementos hijos inmediatos)
- div + p (+ Elementos adyacentes (osea mas cercano) posteriores)
- div ~ p (~ Elementos en el mismo nivel posteriores)

#Selectores por atributo
- a[href^=http] (Elemento a del atributo href que comience con http)
- a[href$=".html"] (Elemento a del atributo href que termine con http)
- input[type="text"]


#Selectores n-child


Colores:
#Definiciones de colores
-#FF0000 (Hexadecimal)
-#F00 (Hexadecimal a 3 digitos ya que se repite la F el 0 y el ultmo 0 de #FF0000)  
-rgb(255,0,0) (RGB Decimal rgb(r, g, b))
-rgb(10%,20%,30%) (RGB en porcentaje rgb(%r, %g, %b))
-red (Por nombre de color)
-rgba(255,0,0,0.5) (el ultimo valor alfa indica la opacidad, el valor debe ser entre 0 y 1)
-hsl(120,65%,75%) (El primero representa el grado del color, los 2 ultimos expresan saturacion e iluminacion expresada en %)
-hsla(120,65%,75%,0.5)


#Degradados:
linear-gradient(to  bottom, blue, white) (El degradado va de arriba a abajo comenzando con un color azul terminando en color blanco)
radial-gradient(red, yellow, rgb(30,144,255)) (El degradado va del centro rojo, enseguida un tono amarillo y la parte externa un azul)


Fuentes:
- La sintaxis para utilizar las fuentes es @font-face, el nombre del font-family que se defina aqui dentro, es el mismo que se colocara en el font-family donde se vaya a utilizar
- Se pueden descargar fuentes personalizadas de GoogleFonts
Ejm: roboto, y se coloca el link correspondiente en el index principal de la aplicacion q se este trabajando.
	<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


Iconos:
- Se pueden descargar fuentes personalizadas de GoogleFonts
Ejm:
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">


Flexible-Box:
#La sintaxis para utilizar flex-box es: display:box o display:inline-box
- Al asignar esta propiedad a un elemento permite controlar el flujo y la posicion de los elementos hijos.
- Los elementos hijos pueden tener propiedades como box-align (horizontal, vertical), box-pack (start, end, center, justify), box-flex (Define una proporcion), box-direction, box-ordinal-group


Bordes:
#Se utiliza la propiedad border-radius en px, si este se aplica a un div, generara un elemento con bordes redondeados.


Fondos Multiples:
- background-imgage:url(imagen1), url(imagen2)
- background-position:left top (le aplica a la imagen1), right bottom (le aplica a la imagen2)
- background-color:#fff
- background-repeat:no-repeat


Transformaciones:
- rotacion transform:rotate(45deg) grados
- traslacion transform:translate(despx, despy)
- inclinacion transform:skew(gradosx, gradosy)
- escalamiento transform:scale(escalarx, escalary)


Transiciones:
- transition: all 2s
- transition-property transition-property:all
- transition-duration transition-duration:0.5s
- transition-timing transition-timing:ease-in
- transition-delay transition-delay:1s (retraso al animar)


Animations:
- animation-name: desplazamiento @keyframes desplazamiento{...}


Padding:
- Margen interna


Margin:
- Margen Externa


Posicionamiento:
- float permite posicionar los elmentos de tipo block por ejm a la izquierada con left uno al lado de otro o a la derecha con right
- clear: both permite limpiar al elemento al cual se le esta aplicando para que no tenga en cuenta los elementos float left y float right
- Para centrar un elemento de tipo block se puede utilizar margin: 0px auto, Para centrar algo horizontalmente en navegadores modernos, usa display: flex; justify-content: center;
- position: relative (Posicionamiento por defecto)
- position: absolute (Permite mover un elemento a cualquier lugar de la pagina adicionando tambien las propiedades top, left, etc) esta propiedad acompaña al scroll
- position: fixed o sticky (Permite mover un elemento a cualquier lugar de la pagina adicionando tambien las propiedades top, left, etc) esta propiedad NO acompaña al scroll queda fija en el lugar que se establezca


Pseudoclases:
- En VSC se puede utilizar : enseguida del atributo para ver las pseudoclases que se pueden utilizar, Ejm ul li : {...}
- Para enlaces por ejm, link, hover, active, visited, etc
- Para inputs por ejm focus, etc
- Para listas por ejm first-child, etc


MediaQuery:
# Definicion de estilos para diseño responsive
- Se pueden definir con @media dentro de la hoja de estilos
- Se pueden definir en una hoja de estilos independiente adicionando el atributo media
Ejm: <link rel="stylesheet" href="css/moviles.css" media="only screen and (max-width:480px) and (min-width:0px)">
- Importante definir el meta: <meta name="viewport" content="width=device-width"> para aplicar estilos segun el ancho del dispositivo no del navegador


Flexbox:
# Contenedor
# Para trabajar con flexbox se deben colocar los elementos a maquetar dentro de un div que funciona como contenedor, el contenedor debe tener la propiedad display:flex o inline-flex
- display : flex es como tener un float : left es decir los elemenos se ubican de manera horizontal uno al lado del otro
- display : flex ocupa el ancho maximo
- display : inline-flex ocupa el ancho o se adapta al contenido
- flex-direction : row o column (row es el comportamiento por default)
- flex-wrap : wrap o nowrap (nowrap es el comportamiento por default), se debe usar wrap para que no se desborden los elementos del contenedor
- flex-flow : row wrap (es la combinacion en una sola, de flex-direction y flex-wrap)
- justify-content Se utiliza para alinear los elementos horizontalmente
- align-items Se utiliza para alinear los elementos verticalmente
- El contenedor puede o no estar dentro de un div general

# Elementos del contenedor
- order : 1 Se aplica a los elementos que estan dentro del contenedor, se pueden organizar segun se desee
- flex-grow : 1 Nomalmente = 1 y sirve para que cada elemento al interior del contenedor ocupe el mismo espacio, se puede tambien asignar de forma independiente a cada elemento, el flex-grow como tal sirve para especificar que cantidad de espacio puede ocupar cada elemento
- flex-shrink : 0 Sirve para reducir el espacio de un elemento es como el opuesto del flex-grow
- flex-basis : calc((100% / 3) - 68px) El flex-basis sirve para definir un tamaño (como si fuera un width) y con la funcion calc se pueden hacer operaciones
- align-self Da una alineacion vertical al elemento que esta dentro del contenedor


Grid Layout:
# Contenedor
- display : grid
- Se define un div que envuelve el grid a construir con display:grid
- grid-template-columns: 50% 45% Permite definir 2 columnas para el grid 
- grid-template-columns: repeat(4, 1f) Permite definir 4 columnas de una fraccion para el grid
- grid-gap : 10px Permite establecer un espacio entre elementos del grid
- grid-template-rows: 1fr 1fr 1fr Permite definir 3 filas para el grid

# Elementos del Grid
- grid-column-start : 1
- grid-column-end : 3
- Las 2 propiedades anteriores expandirian un elemento a nivel de columnas
- grid-column : 1 / 3 Esta propiedad permite el mismo efecto de las 2 propiedades anteriores
- grid-row-start : 2
- grid-row-end : 4
- Las 2 propiedades anteriores expandirian un elemento a nivel de filas
- grid-row : 2 / 4 Esta propiedad permite el mismo efecto de las 2 propiedades anteriores

# En un elemento del grid se puede utilizar flex para alinear horizontal y verticalmente contenido, Ejm:
#cabecera{
	display:flex;
	justify-content:center;
	align-items:center;
	grid-colum: 1 / 6;
}

#Grid Template Area
- En el contenedor se define el template con, Ejm:
- grid-template-areas : 
 "cabecera cabecera cabecera cabecera cabecera"
 "menu menu menu menu menu"
 "contenido contenido contenido contenido lateral"
 "pie pie pie pie pie"
 
- En los elementos del contenedor se debe establecer el identificador correspondiente, Ejm:
- grid-area: cabecera;
- grid-area: pie;

###############################################################################################################################################################
############################################################################## SASS ###########################################################################
###############################################################################################################################################################

Es un pre-procesador CSS https://sass-lang.com/

# Instalacion
- npm install -g sass


# Compilacion
- Ejecutar el comando: sass --watch estilos.scss styles.css  //El watch es para que tome los cambios automaticamente

#Imports
- Se pueden exportar todos los recursos de un archivo .scss a otro archivo .scss con el @import
Ejm: 
	Se tiene un archivo colors.scss con la propiedad $micolor:#cbcbcb;
	Se tiene un archivo button.scss con la propiedad @import "colors";
	.button {
		.backgraound-color: $micolor
	}


# Variables
- Empiezan por $, ejem:
$base-color: #c6538c;
$border-dark: rgba($base-color, 0.88);

.alert {
  border: 1px solid $border-dark;
}


# Anidacion
- Se pueden tener elementos al interior de otros Ejm:
.caja {
	...
	h1 {
		...
	}
}


# Modulos
- El contenido de un archivo .scss se puede usar en otro archivo scss
Ejm: Existen 2 archivos llamados estilos.scss y _base.scss
En el archiv0 estilos.scss se pue llamar el contenido del archivo _base.scss mediante @use:
@use 'base';


# Mixins (Permite agregar dinamicamente y multiples veces la misma estructura css en diversas expresiones)
- Son funciones llamadas (con o sin parametros) mediante @include, Ejm:
@mixin crearBordes($color, $size, $shadow) {
	border: $size solid $color;
	border-radius: $size;
	box-shadow: 0px 0px $size $shadow;
}
.listado {
	@include crearBordes(green, 5px, black);
}


# Herencia
- Son como los mixins pero sin parametros, se llaman mediante @extends, Ejm:
%alert{
	color:white
}
.alert-danger{
	@extends %alert;
	background: red;
}
.alert-success{
	@extends %alert;
	background: green;
}


# Operadores
- Tales como + - * / Ejm:
.caja {
	float:left;
	width: 200px / 900px * 100%; //Daria un ancho en porcentaje
	margin: 10px;
}


# Condicional - if
- Se utiliza @if, @elese, @else if, Ejm:
h1 {
	@if $color-fondo == #ccc {
		color: black;
	} @else if $color-fondo == black {
		color: white;
	} else {
		color: lightsalmon;
	}
}


# Bucle 
- Se utiliza for, each, while, Ejm:
$contador: 1;
@for $contador from 1 through 10 {
	.listado ul li : nth-child(#{$contador}) {
		font-size: $contador * 2px;
	}
}


###############################################################################################################################################################
########################################################################## LESS ###############################################################################
###############################################################################################################################################################

Es un pre-procesador CSS https://sass-lang.com/

# Instalacion
- npm install -g less


# Compilacion
- Ejecutar el comando: lessc estilos.less styles.css


# Variables
- Empiezan por @, ejem:
@bgColor : lightblue;
@b : body;

@{b} { // Equivale al body {...}
	background : @bgColor;	
}


# Anidacion
- Se pueden tener elementos al interior de otros Ejm:
.informacion {
	ul {
		a {
			color : green;
			font-size : 18px;
		}
	}
}


# Mixins
- Son funciones llamadas (con o sin parametros) mediante ., Ejm:
.sombras(@size) {
	box-shadow: 0px 0px @size gray;
}
.informacion {
	.sombras(5px);
}


# Operadores
- Tales como + - * / Ejm:
h1 {
	font-size : 30px + 7px;
}


# Condicionales
- Ejm:
.textoNegro (@value) when (@value=true) {
	color: black;
}
h1 {
	color: blue;
	.textoNegro(true);
}


###############################################################################################################################################################
######################################################################### BOOTSTRAP ###########################################################################
###############################################################################################################################################################

#####Bootstrap#####
De la pagina https://getbootstrap.com/ copia la ruta de css
Ejm: <!-- CSS only -->
<!-- CSS only -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
Y pegarla en el archivo index.html en la seccion correspondiente